[{"title":"Test测试 文章","url":"/2025/04/23/Test%E6%B5%8B%E8%AF%95-%E6%96%87%E7%AB%A0/","content":"测试笔记\n  \n    \n      信息\n\n    \n    \n      换行测试换行测试换行测试\n\n    \n  \n\n  \n    \n      提示\n\n    \n    \n      换行测试换行测试换行测试\n\n    \n  \n\n  \n    \n      自定义标题\n\n    \n    \n      换行测试换行测试换行测试\n\n    \n  \n\n\n  \n    默认 提示块标签 \n\n   \n  \n    default 提示块标签\n\n   \n  \n    primary 提示块标签 \n\n   \n  \n    success 提示块标签 \n\n   \n  \n    info 提示块标签 \n\n   \n  \n    warning 提示块标签 \n\n   \n  \n    danger 提示块标签 \n\n   \n  \n    自定义提示块标签 \n\n  \n\n按钮不设置任何参数的 按钮 适合融入段落中。\nregular 按钮适合独立于段落之外：\n 示例博客\n 示例博客\nlarge 按钮更具有强调作用，建议搭配 center 使用：\n 开始使用\n\n折叠卡片Folding 测试： 点击查看更多 \n              \n              啊啊啊啊啊      danger 提示块标签         tip 提示块标签   \n              \n            \n\n选项卡First TabSecond TabThird TabThis is Tab 1.This is Tab 2.\nThis is Tab 2.This is Tab 3.\nThis is Tab 3.\nThis is Tab 3.\n\n数学$$\\sum_i^n \\frac{1}{n_i+1} \\times k$$\ncodetypedef long long LL;typedef pair&lt;int, int&gt; PII;typedef pair&lt;LL, LL&gt; PLL;#define endl &#x27;\\n&#x27;#define fi first#define se second#define pb push_back#define sz(x) x.size()#define all(x) x.begin(), x.end()#define rep(i, l, r) for(LL i = l; i &lt;= (r); ++ i)#define per(i, r, l) for(LL i = r; i &gt;= (l); -- i)#define reps(i, l, r, d) for(LL i = l; i &lt;= (r); i += d)#define pers(i, r, l, d) for(LL i = r; i &gt;= (l); i -= d)","categories":["Test-categories"],"tags":["Test-tag"]},{"title":"测试2","url":"/2025/04/23/%E6%B5%8B%E8%AF%952/","content":"DP 复建\n背包问题\n0&#x2F;1 背包（每件物品最多只拿一次）\n\n$$\nf[i][j] &#x3D; max(f[i - 1][j] ， f[i - 1][j - v[i]] + w[i])\n$$\n\n完全背包（每件物品有无限个）\n\n未优化$$f[i][j] &#x3D; max(f[i - 1][j] ， f[i - 1][j - k * v[i]] + k * w[i])$$优化后$$f[i][j] &#x3D; max(f[i - 1][j] ， f[i][j - v[i]] + w[i])$$\n\n多重背包（每个物品的数量有$s_i$​个）\n\n未优化$$f[i][j] &#x3D; max(f[i][j] ， f[i - 1][j - k * v[i]] + k * w[i])$$优化后(二进制优化后 &#x3D; 0&#x2F;1背包)$$f[i][j] &#x3D; max(f[i - 1][j] ， f[i - 1][j - v[i]] + w[i])$$\n\n分组背包（每组物品最多只能选一个）\n\n$$f[i][j] &#x3D; max(f[i -1][j] , f[i - 1][j - v[i][k] + w[i][k]])$$\n\n线性DP\n\n数字三角形\n\n$$dp[i][j] &#x3D; max(dp[i - 1][j - 1] , dp[i - 1][j]) + a[i][j];$$\n倒着DP不需要考虑边界问题。\n\n最长上升子序列\n\n$$dp[i] &#x3D; max(dp[i] , dp[j] + 1) \\(a[i] &gt; a[j])$$\n可以单调栈 &#x2F; 二分优化\n\n最长公共子序列\n\n$$a[i] &#x3D; b[j] -&gt; dp[i][j] &#x3D; dp[i - 1][j - 1] + 1 \\a[i] !&#x3D; b[j] -&gt; dp[i][j] &#x3D; max(dp[i - 1][j] , dp[i][j - 1])$$\n\n最短编辑距离\n\n$$dp[i][j] &#x3D; min(\\dp[i - 1][j] + 1(删a[i]), \\dp[i][j - 1] + 1 (加b[j])) \\dp[i - 1][j - 1] (a[i] &#x3D;&#x3D; b[j])\\dp[i - 1][j - 1] + 1 (a[i] !&#x3D; b[j])\\)$$\n\n区间DP\n\n石子合并\n\n$$dp[i][j] &#x3D; min(dp[i][k] + dp[k + 1][j] + w[i][j])$$\n","categories":["多模态","论文"],"tags":["深度学习","AI"]}]